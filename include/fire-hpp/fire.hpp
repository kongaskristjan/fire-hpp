
/*
    Copyright Kristjan Kongas 2020-2024

    Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

// See https://github.com/kongaskristjan/fire-hpp for library's documentation and updates

// Please read /docs/algorithm.md to understand this file

#ifndef FIRE_HPP_
#define FIRE_HPP_

#include <string>
#include <iostream>
#include <sstream>
#include <vector>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <cassert>
#include <cstdlib>
#include <cstddef>
#include <algorithm>
#include <type_traits>
#include <limits>
#include <cstring>
#include <memory>

#if defined(__EXCEPTIONS) || defined(_CPPUNWIND)
#define FIRE_EXCEPTIONS_ENABLED_
#endif

namespace fire {
    constexpr int _failure_code = 1;

    ///// Generic utility functions and classes /////

    template<typename R, typename ... Types>
    constexpr size_t _get_argument_count(R(*)(Types ...)) { return sizeof...(Types); }

    inline int _count_hyphens(const std::string &s);
    inline std::string _without_hyphens(const std::string &s);
    inline std::string _replace_all(const std::string &data, const std::string &from, const std::string &to);

    inline void _instant_assert(bool pass, const std::string &msg, bool programmer_side);
    inline void _api_assert(bool pass, const std::string &msg); // Programmer side assert
    inline void input_assert(bool pass, const std::string &msg); // CLI user side assert, can be called in fired_main
    inline void input_error(const std::string &msg); // equivalent to input_assert with pass==false

    template<typename ORDER, typename VALUE>
    class _smallest {
        ORDER _order;
        VALUE _value;
        bool _empty = true;

    public:
        void set(const ORDER &order, const VALUE &value);
        const VALUE & get() const;
        bool empty() const { return _empty; }
    };

    // Tear-down version of C++17 std::optional
    template <typename T>
    class optional {
        T _value = T();
        bool _exists = false;

    public:
        optional() = default;
        optional(T value): _value(std::move(value)), _exists(true) {}
        optional<T>& operator=(const T& value) { _value = value; _exists = true; return *this; }
        bool operator==(const optional<T>& other) const { return _exists == other._exists && _value == other._value; }
        explicit operator bool() const { return _exists; }
        bool has_value() const { return _exists; }
        T value_or(const T& def) const { return _exists ? _value : def; }
        T value() const { _api_assert(_exists, "accessing unassigned optional"); return _value; }
    };

    ///// fire-hpp's mechanics /////

    // Exception object used in introspection
    struct _escape_exception {
    };

    // Get argc and argv from main() function
    class c_args {
        int _argc = 0;
        char ** _argv = nullptr;

    public:
        inline c_args() = default;
        inline c_args(const std::string &executable, const std::vector<std::string> &args);
        inline c_args& operator=(const c_args &other);
        inline c_args(const c_args &_other) { *this = _other; }
        inline ~c_args();

        inline int &argc() { return _argc; }
        inline char ** argv() { return _argv; }

    private:
        inline void delete_storage();
    };

    static c_args raw_args;

    // Tests whether argument information matches one specified for fire::arg, compare fire::arg-s (that they are not overlapping),
    // create helpful names for fire::arg in help messages
    class identifier {
        optional<int> _pos;
        optional<std::string> _short_name, _long_name, _pos_name, _descr;
        bool _variadic = false;
        bool _optional = false; // Only used for operator<
        bool _flag = false; // Only used for operator<

        std::string _help, _longer;

    public:
        enum class type { not_specified=-1, positional=0, named=1, flag=2 };

        inline static std::string prepend_hyphens(const std::string &name);

        identifier() = default;
        inline identifier(const std::vector<std::string> &names, optional<int> pos, bool is_variadic = false);

        inline void set_as_flag() { _flag = true; }

        inline void append_descr(const std::string &s) { if(_descr.has_value()) _descr = _descr.value() + " " + s; else _descr = s; }

        inline optional<std::string> short_name() const { return _short_name; }
        inline optional<std::string> long_name() const { return _long_name; }

        inline type get_type() const;
        inline bool operator<(const identifier &other) const;
        inline bool operator==(const identifier &other) const;
        inline bool overlaps(const identifier &other) const;
        inline bool contains(const std::string &name) const;
        inline bool contains(int pos) const;
        inline std::string help() const { return _help; }
        inline std::string longer() const { return _longer; }
        inline optional<int> get_pos() const { return _pos; }
        inline void set_optional(bool optional) { _optional = optional; }
        inline bool variadic() const { return _variadic; }

        inline std::string get_descr() const { return _descr.value_or(""); }
    };

    // Matches identifiers (from fire::arg) to actual command line arguments
    class _matcher {
        std::string _executable;
        std::vector<std::string> _positional;
        std::vector<std::pair<std::string, optional<std::string>>> _named;
        std::vector<identifier> _queried;
        _smallest<identifier, std::string> _deferred_error;
        int _main_args = 0;
        bool _introspect = false;
        bool _strict = false;
        bool _help_flag = false;
        bool _allow_unused = false;

    public:
        enum class arg_type { string_t, bool_t, none_t };

        inline _matcher() = default;
        inline _matcher(int argc, const char **argv, int main_args, bool strict, bool allow_unused);

        inline void check(bool dec_main_args);
        inline void check_named();
        inline void check_positional();
        inline void set_allow_unused(bool allow_unused) { _allow_unused = allow_unused; }

        inline std::pair<std::string, arg_type> get_and_mark_as_queried(const identifier &id);
        inline void parse(int argc, const char **argv);
        inline std::vector<std::string> to_vector_string(int n_strings, const char **strings);
        inline std::vector<std::string> equate_assignments(
                const std::vector<std::string> &raw, const std::vector<std::string> &assigned);
        inline std::tuple<std::vector<std::string>, std::vector<std::string>>
                separate_named_positional(const std::vector<std::string> &eqs);
        inline std::vector<std::string> expand_single_hyphen(const std::vector<std::string> &named);
        inline std::vector<std::pair<std::string, optional<std::string>>>
                assign_named_values(const std::vector<std::string> &split);
        inline const std::string& get_executable() { return _executable; }
        inline size_t pos_args() { return _positional.size(); }
        inline bool deferred_assert(const identifier &id, bool pass, const std::string &msg); // Non-immediate assert (signals user error)

        inline void set_introspect(bool introspect) { _introspect = introspect; }
        inline bool get_introspect() const { return _introspect; }

        inline optional<std::string> match_named(const identifier &id) const;
    };

    // Gather function argument info from introspection
    class _arg_logger {
    public:
        struct elem {
            enum class type { none, string, integer, real };

            std::string descr;
            type t;
            std::string def;
            bool optional;
        };

    private:
        std::string _program_descr;
        std::vector<std::pair<identifier, elem>> _params;
        int _introspect_count = 0;

        inline std::string _make_printable(const identifier &id, const elem &elem, bool verbose);
        inline void _add_to_help(std::string &usage, std::string &options,
                                 const identifier &id, const elem &elem, size_t margin);
    public:
        inline void print_help();
        inline std::vector<std::string> get_assignment_arguments() const;
        inline void log(const identifier &name, const elem &elem);
        inline void set_introspect_count(int count);
        inline void set_program_descr(const std::string &program_descr) { _program_descr = program_descr; }
        inline int decrease_introspect_count();
        inline int get_introspect_count() const { return _introspect_count; }
        inline optional<identifier> match_identifier(const identifier &id) const;
    };

    // Static storage for matcher and logger
    template <typename T_VOID = void>
    struct _storage {
        static _matcher matcher;
        static _arg_logger logger;
    };

    template <typename T_VOID>
    _matcher _storage<T_VOID>::matcher;

    template <typename T_VOID>
    _arg_logger _storage<T_VOID>::logger;

    using _ = _storage<void>;

    struct variadic {
    };

    ///// Constraint classes for bound and one_of /////

    class _constraint {
    public:
        virtual std::unique_ptr<_constraint> clone() const = 0;
        virtual void check_constraint(const identifier &, long long) const { _api_assert(false, "Constraint applied to wrong type argument (integral type)"); }
        virtual void check_constraint(const identifier &, long double) const { _api_assert(false, "Constraint applied to wrong type argument (floating point type)"); }
        virtual void check_constraint(const identifier &, const std::string &) const { _api_assert(false, "Constraint applied to wrong type argument (string type)"); }
        virtual ~_constraint() = default;
    };

    template<typename T>
    class _bound: public _constraint {
        T bound;
        bool upper;

    public:
        inline _bound(T bound, bool upper): bound(bound), upper(upper) {}
        inline std::unique_ptr<_constraint> clone() const override { return std::unique_ptr<_constraint>(new _bound(bound, upper)); }

        inline void check_constraint(const identifier &id, long long val) const override;
        inline void check_constraint(const identifier &id, long double val) const override;
    };

    class _one_of: public _constraint {
        std::vector<long long> ll_values;
        std::vector<long double> ld_values;
        std::vector<std::string> s_values;

    public:
        _one_of(std::vector<long long> ll_values, std::vector<long double> ld_values, std::vector<std::string> s_values):
            ll_values(std::move(ll_values)), ld_values(std::move(ld_values)), s_values(std::move(s_values)) {}

        template <typename T, typename std::enable_if<std::is_integral<T>::value>::type* = nullptr>
        explicit _one_of(std::vector<T> values): _one_of(std::vector<long long>(values.begin(), values.end()), {}, {}) {}
        template <typename T, typename std::enable_if<std::is_floating_point<T>::value>::type* = nullptr>
        explicit _one_of(std::vector<T> values): _one_of({}, std::vector<long double>(values.begin(), values.end()), {}) {}
        template <typename T, typename std::enable_if<std::is_same<T, std::string>::value>::type* = nullptr>
        explicit _one_of(std::vector<T> values): _one_of({}, {}, std::move(values)) {}

        inline std::unique_ptr<_constraint> clone() const override { return std::unique_ptr<_constraint>(new _one_of(*this)); }

        template<typename T1, typename T2>
        inline void check_constraint_template(const identifier &id, const std::string &type_name, const std::vector<T1> &values, T2 cur_val) const;

        inline void check_constraint(const identifier &id, long long val) const override { check_constraint_template<long long, long long>(id, "integer", ll_values, val); }
        inline void check_constraint(const identifier &id, long double val) const override;
        inline void check_constraint(const identifier &id, const std::string &val) const override { check_constraint_template<std::string, std::string>(id, "string", s_values, val); }
    };

    ///// fire-hpp's mechanics /////

    // Can be converted to various types to get command line arguments. Actual conversion mechanics happen at _get() and _get_with_precision()
    class arg {
        identifier _id; // No identifier implies vector positional arguments

        optional<long long> _int_value;
        optional<long double> _float_value;
        optional<std::string> _string_value;

        std::vector<std::unique_ptr<_constraint>> _constraints;

        template<typename T>
        inline void _check_constraints(T value) const;

        template <typename T>
        optional<T> _get() { T::unimplemented_function; } // no default function

        template <typename T, typename std::enable_if<std::is_integral<T>::value && ! std::is_same<T, bool>::value>::type* = nullptr>
        optional<T> _get_with_precision();
        template <typename T, typename std::enable_if<std::is_floating_point<T>::value>::type* = nullptr>
        optional<T> _get_with_precision();
        template <typename T, typename std::enable_if<std::is_same<T, bool>::value || std::is_same<T, std::string>::value, bool>::type* = nullptr>
        optional<T> _get_with_precision() { return _get<T>(); }

        template <typename T> optional<T> _convert_optional(bool dec_main_args=true);
        template <typename T> T _convert(bool dec_main_args=true);
        inline void _log(_arg_logger::elem::type t, bool optional);

        template <typename T, typename std::enable_if<std::is_integral<T>::value>::type* = nullptr>
        inline void _init_default(T value) { _int_value = value; }
        template <typename T, typename std::enable_if<std::is_floating_point<T>::value>::type* = nullptr>
        inline void _init_default(T value) { _float_value = value; }
        inline void _init_default(const std::string &value) { _string_value = value; }
        inline void _init_default(std::nullptr_t) {}

        inline arg() = default;

        struct convertible {
            optional<int> _int_value;
            optional<const char *> _char_value;
            bool is_variadic = false;

            convertible(int value): _int_value(value) {}
            convertible(const char *value): _char_value(value) {}
            convertible(variadic): is_variadic(true) {}
        };

    public:
        inline arg(const arg &other) { *this = other; }
        inline arg& operator=(const arg &other);

        template<typename T=std::nullptr_t>
        inline arg(std::initializer_list<convertible> init, T value=T()) {
            optional<int> int_value;
            std::vector<std::string> string_values;
            bool is_variadic = false;
            for(const convertible &val: init) {
                if(val.is_variadic)
                    is_variadic = true;
                else if(val._int_value.has_value())
                    int_value = val._int_value.value();
                else
                    string_values.push_back(val._char_value.value());
            }

            _id = identifier(string_values, int_value, is_variadic);
            _init_default(value);
        }

        template<typename T=std::nullptr_t>
        inline arg(convertible _id, T value=T()):
            arg({_id}, value) {}

        template <typename T, typename std::enable_if<std::is_integral<T>::value>::type* = nullptr>
        inline operator optional<T>() { _log(_arg_logger::elem::type::integer, true); return _convert_optional<T>(); }
        template <typename T, typename std::enable_if<std::is_floating_point<T>::value>::type* = nullptr>
        inline operator optional<T>() { _log(_arg_logger::elem::type::real, true); return _convert_optional<T>(); }
        inline operator optional<std::string>() { _log(_arg_logger::elem::type::string, true); return _convert_optional<std::string>(); }

        template <typename T, typename std::enable_if<std::is_integral<T>::value>::type* = nullptr>
        inline operator T() { _log(_arg_logger::elem::type::integer, false); return _convert<T>(); }
        template <typename T, typename std::enable_if<std::is_floating_point<T>::value>::type* = nullptr>
        inline operator T() { _log(_arg_logger::elem::type::real, false); return _convert<T>(); }
        inline operator std::string() { _log(_arg_logger::elem::type::string, false); return _convert<std::string>(); }
        inline operator bool();

        template <typename T>
        inline operator std::vector<T>();

        // Add constraints
        template <typename T>
        arg min(T mn) const;
        template <typename T>
        arg max(T mx) const;
        template <typename T_min, typename T_max>
        arg bounds(T_min mn, T_max mx) const;

        template<typename T>
        arg one_of(const std::initializer_list<T> &values);
    };

    inline std::string helpful_name(const identifier &id);
    inline std::string helpful_name(int pos);
    inline std::string helpful_name(const std::string &name);

    void _instant_assert(bool pass, const std::string &msg, bool programmer_side) {
        if (pass)
            return;

        if (!msg.empty()) {
            std::cerr << "Error";
            if(programmer_side)
                std::cerr << " (programmer side)";
            std::cerr << ": " << msg << std::endl;
        }

        exit(_failure_code);
    }

    inline void _api_assert(bool pass, const std::string &msg) { _instant_assert(pass, msg, true); }
    inline void input_assert(bool pass, const std::string &msg) { _instant_assert(pass, msg, false); }
    inline void input_error(const std::string &msg) { _instant_assert(false, msg, false); }

    int _count_hyphens(const std::string &s) {
        int hyphens;
        for(hyphens = 0; hyphens < (int) s.size() && s[hyphens] == '-'; ++hyphens)
            ;
        return hyphens;
    }

    std::string _without_hyphens(const std::string &s) {
        int hyphens = _count_hyphens(s);
        std::string wo_hyphens = s.substr(hyphens);
        return wo_hyphens;
    }

    std::string _replace_all(const std::string &data, const std::string &from, const std::string &to) {
        std::string ret = data.substr(0, data.find(from));
        if(data.find(from) == std::string::npos) return ret;

        for(size_t pos = data.find(from); pos != std::string::npos; pos = data.find(from, pos + from.size())) {
            std::size_t shifted_pos = pos + from.size();
            ret += to + data.substr(shifted_pos, data.find(from, shifted_pos) - shifted_pos);
        }
        return ret;
    }


    template<typename ORDER, typename VALUE>
    void _smallest<ORDER, VALUE>::set(const ORDER &order, const VALUE &value) {
        if(_empty || order < _order) {
            _order = order;
            _value = value;
            _empty = false;
        }
    }

    template<typename ORDER, typename VALUE>
    const VALUE & _smallest<ORDER, VALUE>::get() const {
        return _value;
    }


    c_args::c_args(const std::string &executable, const std::vector<std::string> &args) {
        std::vector<std::string> all_args;
        all_args.push_back(executable);
        all_args.insert(all_args.end(), args.begin(), args.end());

        _argc = (int) all_args.size();
        _argv = new char*[all_args.size() + 1]();

        for(size_t i = 0; i < all_args.size(); ++i) {
            _argv[i] = new char[all_args[i].size() + 1]();
            all_args[i].copy(_argv[i], all_args[i].size());
        }
    }

    c_args& c_args::operator=(const c_args &other) {
        if(this == &other) return *this;

        delete_storage();
        _argc = other._argc;
        _argv = new char*[_argc + 1]();

        for(int i = 0; i < _argc; ++i) {
            _argv[i] = new char[strlen(other._argv[i]) + 1]();
            strcpy(_argv[i], other._argv[i]);
        }

        return *this;
    }

    c_args::~c_args() {
        delete_storage();
    }

    void c_args::delete_storage() {
        for(int i = 0; i < _argc; ++i)
            delete [] _argv[i];
        delete [] _argv;
        _argc = 0;
    }


    std::string identifier::prepend_hyphens(const std::string &name) {
        if(name.size() == 1)
            return "-" + name;
        if(name.size() >= 2)
            return "--" + name;
        return name;
    }

    inline identifier::identifier(const std::vector<std::string> &names, optional<int> pos, bool is_variadic) {
        _variadic = is_variadic;

        // Find description, shorthand and long name
        for(const std::string &name: names) {
            if(name.size() >= 2 && name.front() == '<' && name.back() == '>') {
                _pos_name = name;
                continue;
            }

            int hyphens = _count_hyphens(name);
            _api_assert(hyphens <= 2, "Identifier entry " + name + " must prefix either:"
                                                                   " 0 hyphens for description,"
                                                                   " 1 hyphen for short-hand name"
                                                                   " 2 hyphens for long name");
            if(hyphens == 0) {
                _api_assert(!_descr.has_value(),
                            "Can't specify descriptions twice: " + _descr.value_or("") + " and " + name);
                _descr = name;
            } else if(hyphens == 1) {
                _api_assert(!_short_name.has_value(),
                            "Can't specify shorthands twice: " + _short_name.value_or("") + " and " + name);
                _api_assert(name.size() == 2,
                            "Single hyphen shorthand " + name + " must be one character");
                _api_assert(!isdigit(name[1]),
                            "Argument " + name + " can't start with a number");
                _short_name = name;
            } else if(hyphens == 2) {
                _api_assert(!_long_name.has_value(),
                            "Can't specify long names twice: " + _long_name.value_or("") + " and " + name);
                _api_assert(name.size() >= 4,
                            "Two hyphen name " + name + " must have at least two characters");
                _long_name = name;
            }
        }

        // Variadic argument
        if(_variadic) {
            _api_assert(!_short_name.has_value() && !_long_name.has_value()
                        && !_pos.has_value() && !_pos_name.has_value(),
                        "Can't assign a name or position to variadic arguments");
            _help = _longer = "...";
            return;
        }

        // Set help and longer variant
        if(_long_name.has_value() && _short_name.has_value()) {
            _help = _short_name.value() + "|" + _long_name.value();
            _longer = _long_name.value();
        } else if (_long_name.has_value() && ! _short_name.has_value())
            _help = _longer = _long_name.value();
        else if (! _long_name.has_value() && _short_name.has_value())
            _help = _longer = _short_name.value();

        // Set position
        if(pos.has_value()) {
            _api_assert(!_short_name.has_value(),
                        "Can't specify both name " + _short_name.value_or("") + " and index " +
                        std::to_string(pos.value()));
            _api_assert(!_long_name.has_value(),
                        "Can't specify both name " + _long_name.value_or("") + " and index " +
                        std::to_string(pos.value()));
            _pos = pos;
            if(_pos_name.has_value())
                _longer = _help = _pos_name.value();
            else
                _longer = _help = "<" + std::to_string(pos.value()) + ">";
        }
        _api_assert(_short_name.has_value() || _long_name.has_value() || _pos.has_value(),
                    "Argument must be specified with at least on of the following: shorthand, long name or index");

        if(_pos_name.has_value())
            _api_assert(_pos.has_value(),
                        "Positional name " + _pos_name.value_or("") + " requires the argument to be positional");
    }

    inline identifier::type identifier::get_type() const {
        if(_variadic || _pos.has_value())
            return type::positional;
        if(_flag)
            return type::flag;
        return type::named;
    }

    bool identifier::operator<(const identifier &other) const {
        if(get_type() != other.get_type())
            return (int) get_type() < (int) other.get_type();

        std::string name = _long_name.value_or(_short_name.value_or(""));
        std::string other_name = other._long_name.value_or(other._short_name.value_or(""));

        name = _without_hyphens(name);
        other_name = _without_hyphens(other_name);

        std::transform(name.begin(), name.end(), name.begin(), [](char c){ return (char) tolower(c); });
        std::transform(other_name.begin(), other_name.end(), other_name.begin(), [](char c){ return (char) tolower(c); });

        if(name != other_name) {
            if(!name.empty() && !other_name.empty() && _optional != other._optional)
                return _optional < other._optional;
            return name < other_name;
        }
        return _pos.value_or(1000000) < other._pos.value_or(1000000);
    }

    bool identifier::operator==(const identifier &other) const {
        return _pos == other._pos && _short_name == other._short_name && _long_name == other._long_name && _variadic == other._variadic;
    }

    bool identifier::overlaps(const identifier &other) const {
        if(_long_name.has_value() && other._long_name.has_value())
            if(_long_name.value() == other._long_name.value())
                return true;
        if(_short_name.has_value() && other._short_name.has_value())
            if(_short_name.value() == other._short_name.value())
                return true;
        if(_pos.has_value() && other._pos.has_value())
            if(_pos.value() == other._pos.value())
                return true;
        return false;
    }

    bool identifier::contains(const std::string &name) const {
        if(_short_name.has_value() && name == _short_name.value()) return true;
        if(_long_name.has_value() && name == _long_name.value()) return true;
        return false;
    }

    bool identifier::contains(int pos) const {
        return _pos.has_value() && pos == _pos.value();
    }


    _matcher::_matcher(int argc, const char **argv, int main_args, bool strict, bool allow_unused) {
        _main_args = main_args;
        _strict = strict;
        _allow_unused = allow_unused;

        parse(argc, argv);
        identifier help({"-h", "--help", "Print the help message"}, optional<int>());
        _help_flag = get_and_mark_as_queried(help).second != arg_type::none_t;
        check(false);
    }

    void _matcher::check(bool dec_main_args) {
        if(dec_main_args)
            --_main_args;

        if(! _strict || _main_args > 0) return;

        if(_help_flag) {
            _::logger.print_help();
            exit(0);
        }

        if(! _allow_unused) {
            check_named();
            check_positional();
        }

        if(! _deferred_error.empty()) {
            std::cerr << "Error: " << _deferred_error.get() << std::endl;
            exit(_failure_code);
        }
    }

    void _matcher::check_named() {
        int invalid_count = 0;
        std::string invalid;
        for(const auto &it: _named) {
            for(const auto &jt: _queried)
                if(jt.contains(it.first))
                    goto VALID;

            ++invalid_count;
            invalid += " " + it.first;
            VALID:;
        }
        deferred_assert(identifier(), invalid.empty(),
                        std::string("invalid argument") + (invalid_count > 1 ? "s" : "") + invalid);
    }

    void _matcher::check_positional() {
        int invalid_count = 0;
        std::string invalid;
        for(size_t i = 0; i < _positional.size(); ++i) {
            for(const auto &it: _queried)
                if(it.contains((int) i))
                    goto VALID;

            ++invalid_count;
            invalid += " " + _positional[i];
            VALID:;
        }
        deferred_assert(identifier(), invalid.empty(),
                        std::string("invalid positional argument") + (invalid_count > 1 ? "s" : "") + invalid);
    }

    std::pair<std::string, _matcher::arg_type> _matcher::get_and_mark_as_queried(const identifier &id) {
        if(_strict)
            for(const auto& it: _queried)
                _api_assert(!it.overlaps(id), "double query for argument " + id.longer());
        _queried.push_back(id);

        for(auto it = _named.begin(); it != _named.end(); ++it) {
            if (id.contains(it->first)) {
                optional<std::string> result = it->second;
                if (result.has_value())
                    return {result.value(), arg_type::string_t};
                return {"", arg_type::bool_t};
            }
        }

        if(id.get_pos().has_value()) {
            size_t pos = id.get_pos().value();
            if(pos >= _positional.size())
                return {"", arg_type::none_t};

            return {_positional[pos], arg_type::string_t};
        }

        return {"", arg_type::none_t};
    }

    void _matcher::parse(int argc, const char **argv) {
        _executable = argv[0];
        std::vector<std::string> raw = to_vector_string(argc - 1, argv + 1);
        raw_args = c_args(_executable, raw);
        std::vector<std::string> eqs = equate_assignments(raw, _::logger.get_assignment_arguments());
        std::vector<std::string> named;
        tie(named, _positional) = separate_named_positional(eqs);
        named = expand_single_hyphen(named);
        _named = assign_named_values(named);

        for(size_t i = 0; i < _named.size(); ++i)
            for(size_t j = 0; j < i; ++j)
                deferred_assert(identifier(), _named[i].first != _named[j].first,
                                "multiple occurrences of argument " + identifier::prepend_hyphens(_named[i].first));
    }

    std::vector<std::string> _matcher::to_vector_string(int n_strings, const char **strings) {
        std::vector<std::string> raw(n_strings);
        for(int i = 0; i < n_strings; ++i)
            raw[i] = strings[i];
        return raw;
    }

    std::vector<std::string> _matcher::equate_assignments(
            const std::vector<std::string> &raw, const std::vector<std::string> &assigned) {
        std::vector<std::string> eqs;
        size_t i = 0;
        while(i < raw.size()) {
            // Don't parse options after "--"
            if(raw[i] == "--" || (i + 1 < raw.size() && raw[i + 1] == "--")) {
                eqs.insert(eqs.end(), raw.begin() + i, raw.end());
                break;
            }

            // Parse `make -j8` as `make -j=8`
            if(_count_hyphens(raw[i]) == 1 && raw[i].size() > 2 && raw[i][2] != '=') {
                std::string prefix = raw[i].substr(0, 2);
                if(std::find(assigned.begin(), assigned.end(), prefix) != assigned.end()) {
                    eqs.push_back(prefix + "=" + raw[i].substr(2));
                    ++i;
                    continue;
                }
            }

            // Parse `make -j 8` as `make -j=8`
            if(i < raw.size() - 1 && std::find(assigned.begin(), assigned.end(), raw[i]) != assigned.end()) {
                eqs.push_back(raw[i] + "=" + raw[i + 1]);
                i += 2;
                continue;
            }

            // Parse flags without modification
            eqs.push_back(raw[i]);
            ++i;
        }

        return eqs;
    }

    std::tuple<std::vector<std::string>, std::vector<std::string>>
            _matcher::separate_named_positional(const std::vector<std::string> &eqs) {
        std::vector<std::string> named, positional;

        for(size_t i = 0; i < eqs.size(); ++i) {
            const std::string &s = eqs[i];
            int hyphens = _count_hyphens(s);

            if(s == "--") { // Double dash indicates that upcoming arguments are positional only
                positional.insert(positional.end(), eqs.begin() + i + 1, eqs.end());
                break;
            }

            if(! _allow_unused)
                deferred_assert(identifier(), hyphens <= 2, "too many hyphens: " + s);

            if((hyphens == 1 && !isdigit(s[1])) || hyphens == 2)
                named.push_back(s);
            else
                positional.push_back(s);
        }

        return std::tuple<std::vector<std::string>, std::vector<std::string>>(named, positional);
    }

    std::vector<std::string> _matcher::expand_single_hyphen(const std::vector<std::string> &named) {
        std::vector<std::string> new_named;
        for(const std::string &s: named) {
            int hyphens = _count_hyphens(s);
            if(hyphens == 1 && s.find('=') != std::string::npos && s.find('=') >= 3) {
                if(! _allow_unused)
                    deferred_assert(identifier(), false,
                            "expanding single-hyphen arguments can't have value (" + s + ")");
                continue;
            }

            if(hyphens == 1 && s.find('=') == std::string::npos)
                for(size_t i = 1; i < s.size(); ++i) {
                    new_named.push_back(std::string("-") + s[i]);
                }
            else
                new_named.push_back(s);
        }
        return new_named;
    }

    std::vector<std::pair<std::string, optional<std::string>>>
            _matcher::assign_named_values(const std::vector<std::string> &named) {
        std::vector<std::pair<std::string, optional<std::string>>> args;

        for(const std::string &eq: named) {
            size_t index = eq.find('=');
            size_t hyphens = _count_hyphens(eq);
            std::string name = eq;
            if(index == std::string::npos) {
                args.emplace_back(eq, optional<std::string>());
            } else {
                name = eq.substr(0, index);
                std::string value = eq.substr(index + 1);

                args.emplace_back(name, value);
            }
            if(! _allow_unused) {
                size_t name_size = eq.size() - hyphens;
                deferred_assert(identifier(), hyphens <= 2,
                                name + " must have at most two hyphens");
                if (hyphens == 2)
                    deferred_assert(identifier(), name_size >= 2,
                                    "multi-character name " + name + " must have at least two hyphens");
            }
        }
        return args;
    }

    bool _matcher::deferred_assert(const identifier &id, bool pass, const std::string &msg) {
        if(! _strict) {
            input_assert(pass, msg);
            return pass;
        }
        if(! pass)
            _deferred_error.set(id, msg);
        return pass;
    }

    optional<std::string> _matcher::match_named(const identifier &id) const {
        for(const auto &p: _named) {
            const std::string &name = p.first;
            if(id.contains(name))
                return name;
        }
        return optional<std::string>();
    }


    std::string _arg_logger::_make_printable(const identifier &id, const elem &elem, bool verbose) {
        std::string printable;
        if(elem.optional) printable += "[";
        printable += verbose ? id.help() : id.longer();
        if(elem.t != elem::type::none && ! (! verbose && id.get_pos().has_value())) {
            printable += id.get_pos().has_value() ? " " : "=";
            if(elem.t == elem::type::string)
                printable += "STRING";
            if(elem.t == elem::type::integer)
                printable += "INTEGER";
            if(elem.t == elem::type::real)
                printable += "REAL NUMBER";
        }
        if(elem.optional) printable += "]";
        return printable;
    }

    void _arg_logger::_add_to_help(std::string &usage, std::string &options,
                                    const identifier &id, const elem &elem, size_t margin) {
        usage += " ";
        usage += _make_printable(id, elem, false);

        std::string printable = _make_printable(id, elem, true);
        options += "  " + printable + std::string(2 + margin - printable.size(), ' ') + elem.descr;
        if(! elem.def.empty())
            options += " [default: " + elem.def + "]";
        options += "\n";
    }

    void _arg_logger::print_help() {
        using id2elem = std::pair<identifier, elem>;

        std::string usage = "Usage:\n  " + _::matcher.get_executable();
        std::string options;

        std::vector<id2elem> printed(_params);
        for(id2elem &e: printed) {
            e.first.set_optional(e.second.optional);
            if(e.second.t == elem::type::none)
                e.first.set_as_flag();
        }

        std::sort(printed.begin(), printed.end(), [](const id2elem &a, const id2elem &b) {
            return a.first < b.first;
        });

        size_t margin = 0;
        for(const auto& it: printed)
            margin = std::max(margin, _make_printable(it.first, it.second, true).size());

        identifier::type prev_type = identifier::type::not_specified;
        for(const auto& it: printed) {
            identifier::type cur_type = it.first.get_type();
            if (cur_type != prev_type) {
                prev_type = cur_type;

                std::string separator;
                if (cur_type == identifier::type::positional) separator = "Positional arguments";
                if (cur_type == identifier::type::named) separator = "Named arguments";
                if (cur_type == identifier::type::flag) separator = "Flags";
                options += "\n" + separator + ":\n";
            }
            _add_to_help(usage, options, it.first, it.second, margin);
        }

        std::string program_descr;
        if(! _program_descr.empty())
            program_descr = "\n\nDescription:" + _replace_all("\n" + _program_descr, "\n", "\n  ");

        std::cerr << "\n" << usage;
        std::cerr << program_descr << "\n\n";
        std::cerr << options << "\n";
#ifndef FIRE_EXCEPTIONS_ENABLED_
        for(const auto& it: printed) {
            identifier::type cur_type = it.first.get_type();
            if(cur_type == identifier::type::named) {
                std::string name = it.first.longer();
                std::cerr << "\nNotes:\n";
                std::cerr << "  All named arguments must be supplied as an equation.\n"
                          << "  Eg. `./program " << name << "=VALUE`, not `./program " << name << " VALUE`\n\n" << std::flush;
                break;
            }
        }
#endif
    }

    std::vector<std::string> _arg_logger::get_assignment_arguments() const {
        // Returns arguments expecting a value

        std::vector<std::string> args;
        for(const std::pair<identifier, elem> &p: _params)
            if(p.second.t != elem::type::none) {
                optional<std::string> short_name = p.first.short_name();
                if(short_name.has_value())
                    args.push_back(short_name.value());

                optional<std::string> long_name = p.first.long_name();
                if(long_name.has_value())
                    args.push_back(long_name.value());
            }

        return args;
    }

    void _arg_logger::log(const identifier &name, const elem &_elem) {
        elem elem = _elem;
        elem.optional |= ! elem.def.empty();
        _params.emplace_back(name, elem);
    }

    void _arg_logger::set_introspect_count(int count) {
        _introspect_count = count;
        _::matcher.set_introspect(_introspect_count > 0);
    }

    int _arg_logger::decrease_introspect_count() {
        --_introspect_count;
        _::matcher.set_introspect(_introspect_count > 0);
        return _introspect_count;
    }

    inline optional<identifier> _arg_logger::match_identifier(const identifier &id) const {
        for(const std::pair<identifier, elem> &p: _params) {
            const identifier &param_id = p.first;
            if(id.overlaps(param_id))
                return param_id;
        }
        return optional<identifier>();
    }

    inline void print_help() {
        _::logger.print_help();
    }


    template<typename T>
    void _bound<T>::check_constraint(const identifier &id, long long val) const {
        if(std::is_floating_point<T>::value)
            _constraint::check_constraint(id, val);
        if(upper) input_assert(val <= bound, "argument " + helpful_name(id) + " value " + std::to_string(val) + " must be at most " + std::to_string(bound));
        else input_assert(val >= bound, "argument " + helpful_name(id) + " value " + std::to_string(val) + " must be at least " + std::to_string(bound));
    }

    template<typename T>
    void _bound<T>::check_constraint(const identifier &id, long double val) const {
        if(upper) input_assert(val <= bound, "argument " + helpful_name(id) + " value " + std::to_string(val) + " must be at most " + std::to_string(bound));
        else input_assert(val >= bound, "argument " + helpful_name(id) + " value " + std::to_string(val) + " must be at least " + std::to_string(bound));
    }


    template<typename T1, typename T2>
    inline void _one_of::check_constraint_template(const identifier &id, const std::string &type_name, const std::vector<T1> &values, T2 cur_val) const {
        _api_assert(! values.empty(), "converting " + helpful_name(id) + " to " + type_name + ", but values specified in one_of() are not " + type_name + "s");

        bool success = false;
        std::stringstream lst;
        lst << "(";
        for(size_t i = 0; i < values.size(); ++i) {
            if(values[i] == cur_val)
                success = true;
            if(i > 0)
                lst << ", ";
            lst << values[i];
        }
        lst << ")";

        std::stringstream cur_val_str;
        cur_val_str << cur_val;
        input_assert(success, "argument " + helpful_name(id) + " value must be one of " + lst.str() + ", but given was `" + cur_val_str.str() + "`");
    }

    inline void _one_of::check_constraint(const identifier &id, long double val) const {
        if(!ld_values.empty())
            check_constraint_template<long double, long double>(id, "real number", ld_values, val);
        else
            check_constraint_template<long long, long double>(id, "real number", ll_values, val);
    }


    template<typename T>
    inline void arg::_check_constraints(T value) const {
        for(const std::unique_ptr<_constraint> &c: _constraints)
            c->check_constraint(_id, value);
    }

    template <>
    inline optional<long long> arg::_get<long long>() {
        auto elem = _::matcher.get_and_mark_as_queried(_id);
        _::matcher.deferred_assert(_id, elem.second != _matcher::arg_type::bool_t,
                                   "argument " + helpful_name(_id) + " must have value");
        if(elem.second == _matcher::arg_type::string_t) {
            char *end_ptr;
            errno = 0;
            long long converted = std::strtoll(elem.first.data(), &end_ptr, 10);

            if(errno == ERANGE)
                _::matcher.deferred_assert(_id, false, "parameter " + helpful_name(_id) + " value " + elem.first + " out of range");

            _::matcher.deferred_assert(_id, end_ptr == elem.first.data() + elem.first.size(),
                                       "parameter " + helpful_name(_id) + " value " + elem.first + " is not an integer");

            return converted;
        }

        return _int_value;
    }

    template <>
    inline optional<long double> arg::_get<long double>() {
        auto elem = _::matcher.get_and_mark_as_queried(_id);
        _::matcher.deferred_assert(_id, elem.second != _matcher::arg_type::bool_t,
                                   "argument " + helpful_name(_id) + " must have a value");
        if(elem.second == _matcher::arg_type::string_t) {
            char *end_ptr;
            errno = 0;
            long double converted = std::strtold(elem.first.data(), &end_ptr);

            if(errno == ERANGE)
                _::matcher.deferred_assert(_id, false, "parameter " + helpful_name(_id) + " value " + elem.first + " out of range");

            _::matcher.deferred_assert(_id, end_ptr == elem.first.data() + elem.first.size(),
                                       "parameter " + helpful_name(_id) + " value " + elem.first + " is not a real number");

            return converted;
        }

        if(_float_value.has_value()) return _float_value;
        if(_int_value.has_value()) return (long double) _int_value.value();
        return {};
    }

    template <>
    inline optional<std::string> arg::_get<std::string>() {
        auto elem = _::matcher.get_and_mark_as_queried(_id);
        _::matcher.deferred_assert(_id, elem.second != _matcher::arg_type::bool_t,
                                   "argument " + helpful_name(_id) + " must have a value");

        if(elem.second == _matcher::arg_type::string_t) {
            _check_constraints(elem.first);
            return elem.first;
        }

        return _string_value;
    }

    template <typename T, typename std::enable_if<std::is_integral<T>::value && ! std::is_same<T, bool>::value>::type*>
    optional<T> arg::_get_with_precision() {
        optional<long long> opt_value = _get<long long>();
        if(! opt_value.has_value())
            return optional<T>();
        long long value = opt_value.value();
        _check_constraints(value);

        bool is_signed = std::numeric_limits<T>::is_signed;
        T mn = std::numeric_limits<T>::lowest();
        T mx = std::numeric_limits<T>::max();

        _::matcher.deferred_assert(_id, is_signed || value >= 0,
                                   "argument " + helpful_name(_id) + " value " + std::to_string(value) + " must be positive");
        _::matcher.deferred_assert(_id, mn <= value && value <= mx,
                                   "argument " + helpful_name(_id) + " value " + std::to_string(value) + " out of range [" + std::to_string(mn) + ", " + std::to_string(mx) + "]");

        return (T) value;
    }

    template <typename T, typename std::enable_if<std::is_floating_point<T>::value>::type*>
    optional<T> arg::_get_with_precision() {
        optional<long double> opt_value = _get<long double>();
        if(! opt_value.has_value())
            return optional<T>();
        long double value = opt_value.value();
        _check_constraints(value);

        T min = std::numeric_limits<T>::lowest();
        T max = std::numeric_limits<T>::max();

        _::matcher.deferred_assert(_id, min <= value && value <= max,
                                   "argument " + helpful_name(_id) + " value " + std::to_string(value) + " out of range");

        return (T) value;
    }

    template <typename T>
    optional<T> arg::_convert_optional(bool dec_main_args) {
        if(_::matcher.get_introspect())
            return optional<T>();

        _api_assert(!(_int_value.has_value() || _float_value.has_value() || _string_value.has_value()),
                    "optional argument has default value");
        optional<T> val = _get_with_precision<T>();
        _::matcher.check(dec_main_args);
        return val;
    }

    template <typename T>
    T arg::_convert(bool dec_main_args) {
        if(_::matcher.get_introspect())
            return T();

        optional<T> val = _get_with_precision<T>();
        _::matcher.deferred_assert(_id, val.has_value(),
                                   "required argument " + _id.longer() + " not provided");
        _::matcher.check(dec_main_args);
        return val.value_or(T());
    }

    void arg::_log(_arg_logger::elem::type t, bool optional) {
        std::string def;
        if(_int_value.has_value()) def = std::to_string(_int_value.value());
        if(_float_value.has_value()) def = std::to_string(_float_value.value());
        if(_string_value.has_value()) def = _string_value.value();

        _::logger.log(_id, {_id.get_descr(), t, def, optional});

        int count = _::logger.get_introspect_count();
        if(count > 0) { // introspection is active
            count = _::logger.decrease_introspect_count();
            if(count == 0) { // introspection ends
#ifdef FIRE_EXCEPTIONS_ENABLED_
                throw _escape_exception();
#endif
            }
        }
    }

    inline arg& arg::operator=(const arg &other) {
        _id = other._id;
        _int_value = other._int_value;
        _float_value = other._float_value;
        _string_value = other._string_value;

        _constraints.clear();
        for(const std::unique_ptr<_constraint> &c: other._constraints)
            _constraints.push_back(c->clone());

        return *this;
    }

    arg::operator bool() {
        _api_assert(!_int_value.has_value() && !_float_value.has_value() && !_string_value.has_value(),
                    _id.longer() + " flag parameter must not have default value");

        _log(_arg_logger::elem::type::none, true); // User sees this as flag, not boolean option
        auto elem = _::matcher.get_and_mark_as_queried(_id);
        _::matcher.deferred_assert(_id, elem.second != _matcher::arg_type::string_t,
                                   "flag " + helpful_name(_id) + " must not have value");
        _::matcher.check(true);
        return elem.second == _matcher::arg_type::bool_t;
    }

    template <typename T>
    arg::operator std::vector<T>() {
        std::vector<T> ret;
        for(size_t i = 0; i < _::matcher.pos_args(); ++i)
            ret.push_back(arg((int) i)._convert<T>(false));
        _log(_arg_logger::elem::type::none, true);
        _::matcher.check(true);
        return ret;
    }

    template <typename T>
    arg arg::min(T mn) const {
        arg ret = *this;
        ret._id.append_descr("[" + std::to_string(mn) + " <= " + _without_hyphens(_id.longer()) + "]");
        if(std::is_integral<T>::value)
            ret._constraints.push_back(std::unique_ptr<_constraint>((_constraint *) (new _bound<long long>(mn, false))));
        else if(std::is_floating_point<T>::value)
            ret._constraints.push_back(std::unique_ptr<_constraint>((_constraint *) (new _bound<long double>(mn, false))));
        else
            _api_assert(false, "called min with improper argument (not integral or floating point type)");
        return ret;
    }

    template <typename T>
    arg arg::max(T mx) const {
        arg ret = *this;
        ret._id.append_descr("[" + _without_hyphens(_id.longer()) + " <= " + std::to_string(mx) + "]");
        if(std::is_integral<T>::value)
            ret._constraints.push_back(std::unique_ptr<_constraint>((_constraint *) (new _bound<long long>(mx, true))));
        else if(std::is_floating_point<T>::value)
            ret._constraints.push_back(std::unique_ptr<_constraint>((_constraint *) (new _bound<long double>(mx, true))));
        else
            _api_assert(false, "called max with improper argument (not integral or floating point type)");
        return ret;
    }

    template <typename T_min, typename T_max>
    arg arg::bounds(T_min mn, T_max mx) const {
        arg ret = *this;
        ret._id.append_descr("[" + std::to_string(mn) + " <= " + _without_hyphens(_id.longer()) + " <= " + std::to_string(mx) + "]");

        if(std::is_integral<T_min>::value)
            ret._constraints.push_back(std::unique_ptr<_constraint>((_constraint *) (new _bound<long long>((long long) mn, false))));
        else if(std::is_floating_point<T_min>::value)
            ret._constraints.push_back(std::unique_ptr<_constraint>((_constraint *) (new _bound<long double>((long double) mn, false))));
        else
            _api_assert(false, "called bounds with improper argument (not integral or floating point type)");

        if(std::is_integral<T_max>::value)
            ret._constraints.push_back(std::unique_ptr<_constraint>((_constraint *) (new _bound<long long>((long long) mx, true))));
        else if(std::is_floating_point<T_max>::value)
            ret._constraints.push_back(std::unique_ptr<_constraint>((_constraint *) (new _bound<long double>((long double) mx, true))));
        else
            _api_assert(false, "called bounds with improper argument (not integral or floating point type)");

        return ret;
    }


    template<typename T>
    arg arg::one_of(const std::initializer_list<T> &init_values) {
        using T_inter = typename std::conditional<std::is_same<T, const char *>::value, std::string, T>::type;

        std::vector<T_inter> values(init_values.begin(), init_values.end());
        _api_assert(! values.empty(), "one_of constraint with zero possible values supplied");

        std::stringstream descr;
        descr << "[Possible values: (";
        descr << values[0];
        for(size_t i = 1; i < values.size(); ++i)
            descr << ", " << values[i];
        descr << ")]";

        arg ret = *this;
        ret._id.append_descr(descr.str());
        ret._constraints.push_back(std::unique_ptr<_constraint>((_constraint *) (new _one_of(values))));
        return ret;
    }


    inline std::string helpful_name(const identifier &id) {
        if(id.get_type() == identifier::type::positional)
            return helpful_name(id.get_pos().value());

        optional<std::string> matched_name = _::matcher.match_named(id);
        return matched_name.value_or("");
    }

    inline std::string helpful_name(int pos) {
        return identifier(std::vector<std::string>(), pos).help();
    }

    inline std::string helpful_name(const std::string &name) {
        identifier id({name}, optional<int>());
        optional<identifier> matched_id = _::logger.match_identifier(id);
        _api_assert(matched_id.has_value(), "Identifier " + name + " has not been declared");

        optional<std::string> matched_name = _::matcher.match_named(matched_id.value());
        return matched_name.value_or("");
    }
}

#define EXPAND( x ) x // Required to satisfy buggy MSVC compiler (https://stackoverflow.com/q/5134523/6865804)
#define FIRE_EXTRACT_1_(first, ...) first
#define FIRE_EXTRACT_1_PAD_(...) EXPAND( FIRE_EXTRACT_1_(__VA_ARGS__, "") )
#define FIRE_EXTRACT_2_(first, second, ...) second
#define FIRE_EXTRACT_2_PAD_(...) EXPAND( FIRE_EXTRACT_2_(__VA_ARGS__, "", "") )

#define PREPARE_FIRE_(argc, argv, allow_unused, ...) \
    int main_args = (int) fire::_get_argument_count(FIRE_EXTRACT_1_PAD_(__VA_ARGS__));\
    \
    fire::_::logger = fire::_arg_logger();\
    fire::_::matcher = fire::_matcher();\
    fire::_::matcher.set_allow_unused(allow_unused);\
    fire::_::logger.set_introspect_count(main_args);\
    if(main_args > 0) {\
        try {\
            FIRE_EXTRACT_1_PAD_(__VA_ARGS__)(); /* function isn't actually executed, the last default argument will always throw */ \
        } catch (fire::_escape_exception) {\
        }\
    }\
    \
    fire::_::matcher = fire::_matcher(argc, argv, main_args, true, allow_unused);\
    fire::_::logger = fire::_arg_logger();\

// FIRE/FIRE_NO_EXCEPTIONS(fired_main[, program_descr])
// optional parameters implemented using a trick similar to https://stackoverflow.com/a/3048361/6865804

#define FIRE(...) \
int main(int argc, const char ** argv) {\
    PREPARE_FIRE_(argc, argv, false, __VA_ARGS__);\
    fire::_::logger.set_program_descr(FIRE_EXTRACT_2_PAD_(__VA_ARGS__));\
    return FIRE_EXTRACT_1_PAD_(__VA_ARGS__)();\
}

#define FIRE_ALLOW_UNUSED(...) \
int main(int argc, const char ** argv) {\
    PREPARE_FIRE_(argc, argv, true, __VA_ARGS__);\
    fire::_::logger.set_program_descr(FIRE_EXTRACT_2_PAD_(__VA_ARGS__));\
    return FIRE_EXTRACT_1_PAD_(__VA_ARGS__)();\
}

#define FIRE_NO_EXCEPTIONS(...) \
int main(int argc, const char ** argv) {\
    int main_args = (int) fire::_get_argument_count(FIRE_EXTRACT_1_PAD_(__VA_ARGS__));\
    fire::_::matcher = fire::_matcher(argc, argv, main_args, true, false);\
    fire::_::logger.set_program_descr(FIRE_EXTRACT_2_PAD_(__VA_ARGS__));\
    return FIRE_EXTRACT_1_PAD_(__VA_ARGS__)();\
}

#endif
